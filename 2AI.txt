import heapq

graph = {
    'A': [('B', 1), ('C', 5)],
    'B': [('D', 1)],
    'C': [('E', 1)],
    'D': [('F', 1)],
    'E': [('G', 1)],
    'F': [('G', 1)],
    'G': []
}

heuristic = {
    'A': 4,
    'B': 2,
    'C': 1,
    'D': 1,
    'E': 1,
    'F': 1,
    'G': 0
}

def best_first(start, goal):
    visited = set()
    pq = [(heuristic[start], start)]
    path = {}
    while pq:
        _, node = heapq.heappop(pq)
        if node == goal:
            break
        visited.add(node)
        for neighbor, _ in graph[node]:
            if neighbor not in visited:
                heapq.heappush(pq, (heuristic[neighbor], neighbor))
                path[neighbor] = node
    final_path = []
    current = goal
    while current != start:
        final_path.append(current)
        current = path[current]
    final_path.append(start)
    return final_path[::-1]

def a_star(start, goal):
    pq = [(heuristic[start], 0, start)]
    path = {start: None}
    cost = {start: 0}
    while pq:
        f, g, node = heapq.heappop(pq)
        if node == goal:
            break
        for neighbor, w in graph[node]:
            new_g = g + w
            if neighbor not in cost or new_g < cost[neighbor]:
                cost[neighbor] = new_g
                f = new_g + heuristic[neighbor]
                heapq.heappush(pq, (f, new_g, neighbor))
                path[neighbor] = node
    final_path = []
    current = goal
    while current:
        final_path.append(current)
        current = path.get(current)
    return final_path[::-1]

print("Best-First Search Path:", best_first('A', 'G'))
print("A* Search Path:", a_star('A', 'G'))
